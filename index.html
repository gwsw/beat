<!doctype html>
<html>
<head>
<title>Rhythm Practice</title>

</head>
<body onload="init()">

<canvas id="canvas" width="1" height="1"></canvas>

<script>

const avg_bangs          = 10;
const max_bangs          = 30;
const bang_limit         = 0.2;
const shortest_bang      = 120;
const max_offby          = 40;
const bang_light_dur     = 17;
const black_color        = "#000000";
const white_color        = "#ffffff";
const major_grid_color   = "#989898"
const minor_grid_color   = "#707070"

var audioContext = null;
var reset_time = now();
var bangs = null;

class Bangs {
constructor() {
    this.bangs = [];
    this.clear();
}
clear() {
    this.bangs.length = 0;
    this.latest_bang = 0;
    this.beat_ms = 0;
}
count() {
    return this.bangs.length;
}
most_recent() {
    return this.latest_bang;
}
bpm() {
    if (this.beat_ms == 0) return 0;
    let b = 60*1000 / this.beat_ms;
    b = Math.floor(10*b) / 10;
    return b;
}
info(i) {
    return (i == 0 || i >= this.bangs.length) ? null : this.bangs[i];
}
add(bang_tm) {
    let last_bang = (this.bangs.length > 0) ? this.bangs[this.bangs.length-1].time : reset_time;
    if (bang_tm - last_bang < shortest_bang) return;
    this.latest_bang = bang_tm;

    let offby = max_offby;
    let mult = 1;
    if (this.bangs.length > 0) {
        let num_bangs = Math.min(this.bangs.length, avg_bangs);
        let dur = bang_tm - this.bangs[this.bangs.length-1].time;
        let tot = dur;
        for (let i = 1; i < num_bangs; ++i)
            tot += this.bangs[i].time - this.bangs[i-1].time;
        this.beat_ms = tot / num_bangs;
        let mults = [ 1, .5, .25, 2, 3, 4 ];
        let small = this.beat_ms/16;
        for (let m = 0; m < mults.length; ++m) {
            let m1 = mults[m];
            let diff = dur - this.beat_ms*m1;
            if (Math.abs(diff) < small) {
                mult = m1;
                offby = diff;
                break;
            }
        }
        if (mult > 1) {
            let tm = this.bangs[this.bangs.length-1].time;
            for (let i = 0; i < mult-1; ++i) {
                tm += dur/mult;
                this.push_info(tm, 1, 0, true);
            }
        }
    }
    this.push_info(bang_tm, 1/mult, offby, false);
    if (this.bangs.length > max_bangs)
        this.bangs.splice(0, this.bangs.length - max_bangs);
}
push_info(tm, mult, offby, fake) {
    let frac = offby / max_offby;
    if (frac > 1) frac = 1;
    if (frac < -1) frac = -1;
    this.bangs.push({ time:tm, mult:mult, offby:offby, frac:frac, fake:fake });
}
}; // class Bangs

function init() {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        alert("Sorry, your browser does not support getUserMedia");
        return;
    }
    let canvas = canvas_resize();
    canvas.addEventListener('mousedown', canvas_mousepress, false);
    window.addEventListener('resize', canvas_resize, false);
    bangs = new Bangs();
    draw();
}

function canvas_resize() {
    let canvas = document.getElementById("canvas");
    canvas.width = window.innerWidth -20;
    canvas.height = window.innerHeight -20;
    return canvas;
}

function canvas_mousepress(e) {
    if (audioContext == null)
        setupAudio();
    reset();
    draw();
}

async function setupAudio() {
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    audioContext = new AudioContext();
    audioContext.resume();
    let dev = await navigator.mediaDevices.getUserMedia({audio:true});
    if (dev == null || dev.deviceId == '') {
        const devs = await navigator.mediaDevices.enumerateDevices();
        let devid = null;
        for (let i = 0; i < devs.length; ++i) {
            if (devs[i].kind == 'audioinput') {
                devid = devs[i].deviceId;
                break;
            }
        }
        if (devid == null) {
            alert("No microphone found.");
            return;
        }
        dev = await navigator.mediaDevices.getUserMedia({audio:{deviceId:{exact:devid}}});
    }
    let source = audioContext.createMediaStreamSource(dev);
    let proc_node = audioContext.createScriptProcessor(256, 1, 1);
    proc_node.onaudioprocess = process_audio;
    proc_node.connect(audioContext.destination);
    source.connect(proc_node);
}

function reset() {
    reset_time = now();
    bangs.clear();
}

function draw() {
    let ctx = get_ctx();
    let cw = ctx.canvas.width;
    let ch = ctx.canvas.height;
    ctx.clearRect(0, 0, cw, ch);
    draw_rect(ctx, 0, 0, cw, ch, black_color);
    if (audioContext == null) {
        // Chrome requires user click before new AudioContext.
        draw_center_paragraph(ctx, ["Click to begin."], 0, ch/8, cw, white_color, ch/12, "Arial");
    } else if (cw < ch) {
        draw_center_paragraph(ctx, ["Hold phone","sideways."], 0, ch/8, cw, white_color, ch/12, "Arial");
    } else {
        draw_ui(ctx, cw, ch);
    }
    window.requestAnimationFrame(draw);
}

function draw_ui(ctx, cw, ch) {
    let xmargin = Math.floor(cw / 40);
    let ymargin = Math.floor(ch / 40);
    let font_size = Math.floor(ch/6);
    let csh2 = Math.floor(ch/50); // center strip
    let m = measure_text(ctx, "888.8a", font_size, "Arial");
    let panelw = m.width;
    let bpm = bangs.bpm().toString();
    m = measure_text(ctx, bpm, font_size);
    let y = (ch+m.height)/2; 
    draw_text(ctx, bpm, xmargin, y, white_color);
    let lr = font_size/3;
    draw_bang_light(ctx, xmargin+lr, ymargin+lr, lr);

    let midy = ch / 2;
    let maxy = midy - ymargin;
    let gw = cw - panelw - 2*xmargin;
    let bw = 8;
    let x = xmargin + panelw;
    draw_grid(ctx, x, midy, 0, csh2, 0, maxy/4, gw, 0);

    let xstep = gw / (max_bangs-1);
    for (let i = 1; i < bangs.count(); ++i, x += xstep) {
        let info = bangs.info(i);
        let color = bang_color(info.frac);
        let bh = maxy * info.frac;
        let offby = Math.floor(info.offby).toString();
        let m = measure_text(ctx, offby, Math.floor(csh2*1.5), "monospace");
        draw_text(ctx, offby, x, midy, white_color);
        if (bh < 0) {
            draw_rect(ctx, x, midy+bh-csh2, bw, -bh, color);
        } else {
            draw_rect(ctx, x, midy+csh2, bw, bh, color);
        }
    }
}

function draw_grid(ctx,x,y,xi,yi,dxi,dyi,gw,gh) {
    draw_rect(ctx, x+xi, y+yi, gw?gw:1, gh?gh:1, major_grid_color);
    draw_rect(ctx, x-xi, y-yi, gw?gw:1, gh?gh:1, major_grid_color);
    ctx.beginPath();
    ctx.setLineDash([10,4]);
    ctx.strokeStyle = minor_grid_color;
    for (let i = 1; i < 4; ++i) {
        xi += dxi;
        yi += dyi;
        ctx.moveTo(x+xi, y+yi);
        ctx.lineTo(x+xi+gw, y+yi+gh);
        ctx.stroke();
        ctx.moveTo(x-xi, y-yi);
        ctx.lineTo(x-xi+gw, y-yi+gh);
        ctx.stroke();
    }
    ctx.setLineDash([]);
}

function draw_bang_light(ctx, x, y, r) {
    if (now() - bangs.most_recent() > bang_light_dur) return;
    draw_circle(ctx, x, y, r, white_color);
}

function bang_color(frac) {
    return mkcolor(fade({r:0,g:255,b:0}, {r:255,g:0,b:0}, Math.abs(frac)));
}

function process_audio(e) {
    let tm = now();
    let input = e.inputBuffer;
    for (let c = 0; c < input.numberOfChannels; ++c) {
        let samp = input.getChannelData(c);
        let bang_tm = bang_time(samp, tm);
        if (bang_tm > 0) bangs.add(bang_tm);
    }
}

function bang_time(samp, tm) {
    const samples_per_sec = 44100;
    const samples_per_ms = samples_per_sec / 1000;
    for (let b = 0; b < samp.length; b++)
        if (samp[b] > bang_limit)
            return tm - (samp.length - b) / samples_per_ms;
    return 0;
}

function get_ctx() {
    var canvas = document.getElementById("canvas");
    return canvas.getContext("2d");
}

function mkcolor(color) {
    var rx = ("0"+color.r.toString(16)).substr(-2);
    var gx = ("0"+color.g.toString(16)).substr(-2);
    var bx = ("0"+color.b.toString(16)).substr(-2);
    return "#"+rx+gx+bx;
}

function fade(color1, color2, frac) {
    return {
        r: color1.r + Math.floor((color2.r - color1.r) * frac),
        g: color1.g + Math.floor((color2.g - color1.g) * frac),
        b: color1.b + Math.floor((color2.b - color1.b) * frac) };
}

function draw_rect(ctx, x, y, w, h, color) {
    if (color != undefined) ctx.fillStyle = color;
    ctx.fillRect(x, y, w, h);
}

function draw_text(ctx, text, x, y, color, fontsize, fontname) {
    set_font(ctx, fontsize, fontname);
    ctx.fillStyle = color;
    ctx.fillText(text, x, y); //FIXME y baseline weirdness
}

function draw_center_paragraph(ctx, texts, x, y, w, color, font_size, font_name) {
    for (let i = 0; i < texts.length; ++i) {
        let text = texts[i];
        let m = measure_text(ctx, text, font_size, font_name);
        draw_text(ctx, text, x+(w-m.width)/2, y, color);
        y += m.height + 6;
    }
}

function draw_circle(ctx, x, y, r, color) {
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.arc(x, y, r, 0, 2*Math.PI);
    ctx.fill();
}

function measure_text(ctx, str, fontsize, fontname) {
    set_font(ctx, fontsize, fontname);
    var m = ctx.measureText(str);
    return { width: m.width, height: fontsize*.9 }; // FIXME
}

function set_font(ctx, fontsize, fontname) {
    if (fontsize == undefined || fontsize == 0) return;
    if (fontname == undefined || fontname == '') fontname = 'sans-serif';
    ctx.font = fontsize.toString()+'px '+fontname;
}

function now() {
    return performance.now();
    //return (new Date()).getTime();
}
</script>

</body>
</html>
