<!doctype html>
<html>
<head>
<title>Rhythm Practice</title>

</head>
<body onload="init()">

<canvas id="canvas" width="1" height="1"></canvas>

<script>

const max_bangs          = 10;
const bang_limit         = 0.2;
const shortest_bang      = 120;
const max_delta          = 40;
const bang_light_dur     = 17;
const black_color        = "#000000";
const white_color        = "#ffffff";

var bangs = [];
var beat_ms = 0;
////var work_node = null;
var proc_node = null;
var audioContext = null;
var reset_time = now();
var recent_bang = 0;

function init() {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        alert("Sorry, your browser does not support getUserMedia");
        return;
    }
    let canvas = canvas_resize();
    canvas.addEventListener('mousedown', canvas_mousepress, false);
    window.addEventListener('resize', canvas_resize, false);
    draw();
}

function canvas_resize() {
    let canvas = document.getElementById("canvas");
    canvas.width = window.innerWidth -20;
    canvas.height = window.innerHeight -20;
    return canvas;
}

function canvas_mousepress(e) {
    if (audioContext == null)
        setupAudio();
    reset();
    draw();
}

async function setupAudio() {
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    audioContext = new AudioContext();
    audioContext.resume();
    let dev = await navigator.mediaDevices.getUserMedia({audio:true});
    if (dev == null || dev.deviceId == '') {
        const devs = await navigator.mediaDevices.enumerateDevices();
        let devid = null;
        for (let i = 0; i < devs.length; ++i) {
            if (devs[i].kind == 'audioinput') {
                devid = devs[i].deviceId;
                break;
            }
        }
        if (devid == null) {
            alert("No microphone found.");
            return;
        }
        dev = await navigator.mediaDevices.getUserMedia({audio:{deviceId:{exact:devid}}});
    }
    let source = audioContext.createMediaStreamSource(dev);
    ////if (false) {
    ////    work_node = new AudioWorkletNode(audioContext, 'audio-processor');
    ////    work_node.connect(audioContext.destination);
    ////    source.connect(work_node);
    ////} else
    {
        proc_node = audioContext.createScriptProcessor(256, 1, 1);
        proc_node.onaudioprocess = process_audio;
        proc_node.connect(audioContext.destination);
        source.connect(proc_node);
    }
}

function reset() {
    reset_time = now();
    bangs.length = 0;
    beat_ms = 0;
}

function draw() {
    ////if (work_node != null) 
    ////    check_bang(work_node.get_bang());
    let ctx = get_ctx();
    let cw = ctx.canvas.width;
    let ch = ctx.canvas.height;
    ctx.clearRect(0, 0, cw, ch);
    draw_rect(ctx, 0, 0, cw, ch, black_color);
    if (audioContext == null) {
        // Chrome requires user click before new AudioContext.
        let text = "Click to begin.";
        let font_size = (cw > ch) ? ch/8 : cw/12;
        let m = measure_text(ctx, text, font_size, "Arial");
        draw_text(ctx, text, (cw-m.width)/2, (ch-m.height)/2, white_color);
    } else if (cw > ch) {
        draw_landscape(ctx, cw, ch);
    } else {
        draw_portrait(ctx, cw, ch);
    }
    window.requestAnimationFrame(draw);
}

function draw_landscape(ctx, cw, ch) {
    let xmargin = Math.floor(cw / 40);
    let ymargin = Math.floor(ch / 40);
    let font_size = ch/6;
    let m = measure_text(ctx, "888.8a", font_size, "Arial");
    let panelw = m.width;
    let bpm = get_bpm().toString();
    m = measure_text(ctx, bpm, font_size);
    let y = (ch+m.height)/2; 
    draw_text(ctx, bpm, xmargin, y, white_color);
    let lr = font_size/3;
    draw_bang_light(ctx, xmargin+lr, ymargin+lr, lr);
    let midy = ch / 2;
    let maxy = midy - ymargin;
    let gw = cw - panelw - 2*xmargin;
    let bw = 8;
    let x = xmargin + panelw;
    draw_rect(ctx, x, midy, gw, 2, "#505050");
    if (bangs.length < 2) return;
    let xstep = (gw / (bangs.length-1)) - bw;
    for (let i = 1; i < bangs.length; ++i, x += xstep) {
        let frac = bang_frac(i);
        let bh = maxy * frac;
        draw_rect(ctx, x, midy+((bh<0)?bh:0), bw, Math.abs(bh), bang_color(frac));
    }
}

function draw_portrait(ctx, cw, ch) {
    let xmargin = Math.floor(cw / 40);
    let ymargin = Math.floor(ch / 40);
    let font_size = cw/6;
    let m = measure_text(ctx, "8", font_size, "Arial"); // just need height
    let r = font_size / 3;
    let panelh = Math.floor(m.height * 1.7) + 2*r;
    let bpm = get_bpm().toString();
    m = measure_text(ctx, bpm, font_size);
    let y = ymargin+m.height; 
    draw_text(ctx, bpm, (cw-m.width)/2, y, white_color);
    let lr = font_size/3;
    draw_bang_light(ctx, xmargin+lr, ymargin+lr, lr);
    let midx = cw / 2;
    let maxx = midx - xmargin;
    let gh = ch - panelh - 2*ymargin;
    let bh = 8;
    y = ymargin + panelh;
    draw_rect(ctx, midx, y, 2, gh, "#505050");
    if (bangs.length < 2) return;
    let ystep = (gh / (bangs.length-1)) - bh;
    for (let i = 1; i < bangs.length; ++i, y += ystep) {
        let frac = bang_frac(i);
        let bw = maxx * frac;
        draw_rect(ctx, midx+((bw<0)?bw:0), y, Math.abs(bw), bh, bang_color(frac));
    }
}

function draw_bang_light(ctx, x, y, r) {
    if (now() - recent_bang > bang_light_dur) return;
    draw_circle(ctx, x, y, r, white_color);
}

function bang_color(frac) {
    return mkcolor(fade({r:0,g:255,b:0}, {r:255,g:0,b:0}, Math.abs(frac)));
}

function bang_frac(i) {
    let dur = bangs[i] - bangs[i-1];
    let frac = (beat_ms - dur) / max_delta;
    if (frac > 1) frac = 1;
    if (frac < -1) frac = -1;
    return frac;
}

function process_audio(e) {
    let tm = now();
    let input = e.inputBuffer;
    for (let c = 0; c < input.numberOfChannels; ++c) {
        let samp = input.getChannelData(c);
        let bang_tm = bang_time(samp, tm);
        record_bang(bang_tm);
    }
}

function record_bang(bang_tm) {
    let last_bang = (bangs.length > 0) ? bangs[bangs.length-1] : reset_time;
    if (bang_tm - last_bang < shortest_bang) return;
    bangs.push(bang_tm);
    recent_bang = bang_tm;
    while (bangs.length > max_bangs)
        bangs.splice(0, 1);
    if (bangs.length < 2) return;
    let tot = 0;
    for (let i = 1; i < bangs.length; ++i)
        tot += bangs[i] - bangs[i-1];
    beat_ms = tot / (bangs.length-1);
}

function bang_time(samp, tm) {
    const samples_per_sec = 44100;
    const samples_per_ms = samples_per_sec / 1000;
    for (let b = 0; b < samp.length; b++)
        if (samp[b] > bang_limit)
            return tm - (samp.length - b) / samples_per_ms;
    return 0;
}

function get_bpm() {
    if (beat_ms == 0) return 0;
    let bpm = 60*1000 / beat_ms;
    bpm = Math.floor(10*bpm) / 10;
    return bpm;
}

function get_ctx() {
    var canvas = document.getElementById("canvas");
    return canvas.getContext("2d");
}

function mkcolor(color) {
    var rx = ("0"+color.r.toString(16)).substr(-2);
    var gx = ("0"+color.g.toString(16)).substr(-2);
    var bx = ("0"+color.b.toString(16)).substr(-2);
    return "#"+rx+gx+bx;
}

function fade(color1, color2, frac) {
    return {
        r: color1.r + Math.floor((color2.r - color1.r) * frac),
        g: color1.g + Math.floor((color2.g - color1.g) * frac),
        b: color1.b + Math.floor((color2.b - color1.b) * frac) };
}

function draw_rect(ctx, x, y, w, h, color) {
    if (color != undefined) ctx.fillStyle = color;
    ctx.fillRect(x, y, w, h);
}

function draw_text(ctx, text, x, y, color, fontsize, fontname) {
    set_font(ctx, fontsize, fontname);
    ctx.fillStyle = color;
    ctx.fillText(text, x, y); //FIXME y baseline weirdness
}

function draw_circle(ctx, x, y, r, color) {
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.arc(x, y, r, 0, 2*Math.PI);
    ctx.fill();
}

function measure_text(ctx, str, fontsize, fontname) {
    set_font(ctx, fontsize, fontname);
    var m = ctx.measureText(str);
    return { width: m.width, height: fontsize*.9 }; // FIXME
}

function set_font(ctx, fontsize, fontname) {
    if (fontsize == undefined || fontsize == 0) return;
    if (fontname == undefined || fontname == '') fontname = 'sans-serif';
    ctx.font = fontsize.toString()+'px '+fontname;
}

function now() {
    return performance.now();
    //return (new Date()).getTime();
}
</script>

</body>
</html>
